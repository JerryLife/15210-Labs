为方便点的收缩，使用一个临时表来标记各原图中的节点和此时图中代表该节点的节点(即所谓supervertex)，在每一次递归时，都根据收缩的点修改该表的对应项的值。该表并非用于查询，仅用于辅助每一次的点的收缩操作。
算法要求返回原图中的边，但是随着算法的进行，原图中的多个节点会被合并为数量很少的supervertex，如果每次都需要查询，则过于浪费时间（而且维护这样的一个表并不方便，尤其是需要修改多个点属于的supervertex时）。
因此，超边的数据结构表示至少要包含原边e0和两端的supervertex(u,v)，当此边被选中时，添加到最小生成树里的为原边e0。当此超边的相应端点被收缩时，查询临时表并用u和v归属的supervertex来替代边中的值，同时一旦新的u与v相同，则利用filter筛去这样的self-arc。
inject的实现保证有：“If there are duplicate indices in the sequence, the last one is written and the others are ignored.”，那么，只要我们将每个边按照边权w从大到小排序，就可以利用此函数来筛选每个点的最小边，而为了达到此目的，我们需要将：
① 每个边的出发端和剩余信息构建成一个二元组，这样就可以作为inject的修改序列，因此，超边的合适（但不唯一）的表示方法为(u,(v,(u0,v0,w)))。这样，从同一点出发的超边会update seq的同一个位置。
② 初始化一个长度为n的seq，包含元素类型为超边的类型（并且用更新时不会出现的placeholder去填充，比如-1）。
然后，用超边的集合去inject② 中初始化的数组，再用enum把index（其实也就是u）加上，然后filter筛去合适位置（比如v）为placeholder(前例中-1)的元素，即可得到此超边集合中每个supervertex相连的最小权值边。
另外，需要注意的一点是，找到的最小权边的集合并不会被直接加入最后的生成树中，而是挑选出其中成功令一对supervertex合并的那些边来加入生成树中。